////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//   ██████╗ ██████╗  ██████╗ ██╗    ██╗    ██╗  ██╗ █████╗  ██████╗██╗  ██╗███████╗██████╗     ██╗   ██╗ ██╗
//  ██╔════╝ ██╔══██╗██╔═══██╗██║    ██║    ██║  ██║██╔══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    ██║   ██║███║
//  ██║  ███╗██████╔╝██║   ██║██║ █╗ ██║    ███████║███████║██║     █████╔╝ █████╗  ██████╔╝    ██║   ██║╚██║
//  ██║   ██║██╔══██╗██║   ██║██║███╗██║    ██╔══██║██╔══██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    ╚██╗ ██╔╝ ██║
//  ╚██████╔╝██║  ██║╚██████╔╝╚███╔███╔╝    ██║  ██║██║  ██║╚██████╗██║  ██╗███████╗██║  ██║     ╚████╔╝  ██║
//   ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝     ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝      ╚═══╝   ╚═╝
//                                                                                                         
//                                                                                                         
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GHLTHTCD3R4V16i GROW HUCKER LIGHT TEMP HUMI TIMER CONTROL DATAIN 3 RELEOUT 4 VERSION 16/2 i2c

//#include "Arduino.h"
// #include <avr/pgmspace.h>
#include "Dht11.h"
#include <Wire.h>
#include <LiquidCrystal_I2C.h>


// res.h
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// rele type
#define RELE_CONTROL_SET 0 // 0:1 зависит от того каким сигналом управляется реле
#if RELE_CONTROL_SET == 0
#define DW_H 0
#define DW_L 1
#else
#define DW_H 1
#define DW_L 0
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void animationReleDelay();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ██████╗      █████╗     ███████╗    ██████╗     ██╗    ███╗   ██╗     ██████╗     ██╗   ██╗    ██╗  ██╗     █████╗ 
//  ██╔══██╗    ██╔══██╗    ██╔════╝    ██╔══██╗    ██║    ████╗  ██║    ██╔═══██╗    ██║   ██║    ██║ ██╔╝    ██╔══██╗
//  ██████╔╝    ███████║    ███████╗    ██████╔╝    ██║    ██╔██╗ ██║    ██║   ██║    ██║   ██║    █████╔╝     ███████║
//  ██╔══██╗    ██╔══██║    ╚════██║    ██╔═══╝     ██║    ██║╚██╗██║    ██║   ██║    ╚██╗ ██╔╝    ██╔═██╗     ██╔══██║
//  ██║  ██║    ██║  ██║    ███████║    ██║         ██║    ██║ ╚████║    ╚██████╔╝     ╚████╔╝     ██║  ██╗    ██║  ██║
//  ╚═╝  ╚═╝    ╚═╝  ╚═╝    ╚══════╝    ╚═╝         ╚═╝    ╚═╝  ╚═══╝     ╚═════╝       ╚═══╝      ╚═╝  ╚═╝    ╚═╝  ╚═╝
//                                                                                                                   
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// raspinovka
// DS3231, I2C Display 16/2, = A4 A5 I2C interface

// ENKODER;
#define IN_ENKODER_CLK_PIN 2
#define IN_ENKODER_BUTTON_PIN 3
#define IN_ENKODER_DT_PIN 4

// DHT 11;
#define IN_DHT_DATA_PIN 15 // A1
// EXTTENDED .... - VCC/ DHT 22/ SENSOR_POCVI/ GND;
#define EXTENDED_IN_DATCHIK_POCVI A0  // D14
#define EXTENDED_IN_DHT_DATA_PIN 16 // A2

// OUT RELE
#define OUT_SVETTIMER_RELE_PIN 5
#define OUT_POLIVTIMER_RELE_PIN 6
#define OUT_TEMPERATURA_RELE_PIN 7
#define OUT_VLAJNOST_RELE_PIN 8

#define OUT_YARKOST_DISPLEYA_PWM_PIN 9

// init
LiquidCrystal_I2C lcd(0x27, 16, 2); // установка адреса 0x27 и разрешения 16/2 дисплея
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                   


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ███████╗ ███████╗ ██████╗  ███████╗ ███╗   ███╗ ███████╗ ██╗  ██╗ ██╗     ██╗ ██╗  ██╗ ███████╗          ▄▄███▄▄·
//  ██╔══██║ ██╔════╝ ██╔══██╗ ██╔════╝ ████╗ ████║ ██╔════╝ ██║  ██║ ██║     ██║ ██║  ██║ ██╔════╝          █ ███╔═╝
//  ██║  ██║ █████╗   ██████╔╝ █████╗   ██╔████╔██║ █████╗   ███████║ ██████╗ ██║ ███████║ █████╗            ███████╗
//  ██║  ██║ ██╔══╝   ██╔═══╝  ██╔══╝   ██║╚██╔╝██║ ██╔══╝   ██╔══██║ ██╔══██╗██║ ██╔══██║ ██╔══╝            ╚═███ █║
//  ██║  ██║ ███████╗ ██║      ███████╗ ██║ ╚═╝ ██║ ███████╗ ██║  ██║ ██████╔╝██║ ██║  ██║ ███████╗          ███████║
//  ╚═╝  ╚═╝ ╚══════╝ ╚═╝      ╚══════╝ ╚═╝     ╚═╝ ╚══════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚═╝  ╚═╝ ╚══════╝          ╚═▀▀▀══╝
//                                   
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#include "lcdbyte.h"  // символы для дисплея

// language 0 = ENG; 1 = РУС;
byte langFlag = 0;

// ЯРКОСТЬ ДИСПЛЕЯ
byte yarkostDispleya = 10;                // яркость екрана 0 - 100

// display display counter
byte gDispCount = 1;



//  ГЛОБАЛЬНЫЕ ФЛАГИ
bool flagSvetocikla = 0;     // для хранения переменной день или ночь
bool flagSvetocikla2 = 0;    // для хранения переменной день или ночь 2

bool flagPoliva1 = 0;        // для хранения переменной вкл/выкл
bool flagPoliva2 = 0;        // для хранения переменной вкл/выкл 2
bool flagPoliva3 = 0;        // для хранения переменной вкл/выкл 3

bool flagTermorele = 0;      // для хранения переменной вкл/выкл

bool flagHumidityrele = 0;   // для хранения переменной вкл/выкл

byte flagAnimaciiReleStateCounter = 1;  // счетчик флага анимации включеного реле 0 - 5

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ПЕРЕМЕННЫЕ НАВИГАЦИИ ПО МЕНЮ
int vertikalStep = 0;
int horizontalStep = 0;
byte menuVertikalPos = 0;
byte menuHorizontalPos = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ПЕРЕМЕННЫЕ С ДАННЫМИ
//char week[8][10] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
byte second, minute = 61, hour, dayOfWeek, dayOfMonth, month, year;

byte TEMP = 0; // температура
byte HMDT = 0; // влажность
byte calibrValTEMP = 1; // значение + калибровки температуры
byte calibrValHMDT = 27; // значение + калибровки влажносты
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ПЕРЕМЕННЫЕ УПРАВЛЕНИЯ И НАСТРОЙКИ ПАРАМЕТРОВ

// СВЕТОЦИКЛ
byte svetociklType = 1;                      // 2 таймер досветки : 1 таймер светоцикла : 0 отключено
byte vremyaVkluchenieSveta[2] = {12,30};     // время включения реле света
byte vremyaVikluchenieSveta[2] = {19,55};    // время выключения реле света
byte vremyaVkluchenieSveta2[2] = {1,27};     // 2 время включения реле света
byte vremyaVikluchenieSveta2[2] = {1,28};    // 2 время выключения реле света



// АВТОПОЛИВ
byte vremyaViklucheniaNasosa[2] = {25,61}; // во столько выключится насос часов, минут (служебная переменная)

byte polivaRejim = 1;                      // 3 от датчика влажности почвы : 2 по времени : 1 циклический : 0 отключено
byte vremyaRabotiNasosa[2] = {0,1};        // часов, минут работы насоса полива
// в режиме 0 циклический
byte mejduPolivami[2] = {0,15};            // часов, минут между поливами
// в режиме 1 по заданому времени
byte vremyaPoliva1[2] = {6,15};            // время 1 полива часы, минуты
byte vremyaPoliva2[2] = {12,15};           // время 2 полива часы, минуты
byte vremyaPoliva3[2] = {18,15};           // время 3 полива часы, минуты

bool datchikPolivaTypeSet = 1;             // тип работы датчика: 0 аналоговый / 1 цифровой
bool datchikPolivaValSet = 1;              // какой сигнал ждать с датчика почвы: 0 - / 1 + 
byte datchikPolivaValAnalogSet = 50;       // точка сработки датчика полива от 0 до 100



// ТЕМПЕРАТУРА
byte tempRejim = 1;                        // 3 настраиваемый : 2 нагрев : 1 охлаждение : 0 отключено
byte temperaturaUderjania = 23;           // температура которая будет поддерживатся
byte temperaturaVkluchenia = 24;          // температура включения реле температуры
byte temperaturaVikluchenia = 22;         // температура выключения реле температуры
byte gisterezisTemperaturi = 2;           // гистерезис температуры



// ВЛАЖНОСТЬ
byte vlajnostRejim = 2;                    // 3 настраиваемый : 2 увлажнение : 1 сушка : 0 отключено
byte vlajnostUderjania = 23;              // влажность которая будет поддерживатся
byte vlajnostVkluchenia = 50;             // влажность включения реле влажности
byte vlajnostVikluchenia = 60;            // влажность выключения реле влажности
byte gisterezisVlajnosti = 10;            // гистерезис влажности






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  
//  ███████╗    ███╗   ██╗    ██╗  ██╗     ██████╗     ██████╗     ███████╗    ██████╗             ██╗   ██╗
//  ██╔════╝    ████╗  ██║    ██║ ██╔╝    ██╔═══██╗    ██╔══██╗    ██╔════╝    ██╔══██╗            ██║   ██║
//  █████╗      ██╔██╗ ██║    █████╔╝     ██║   ██║    ██║  ██║    █████╗      ██████╔╝            ██║   ██║
//  ██╔══╝      ██║╚██╗██║    ██╔═██╗     ██║   ██║    ██║  ██║    ██╔══╝      ██╔══██╗            ╚██╗ ██╔╝
//  ███████╗    ██║ ╚████║    ██║  ██╗    ╚██████╔╝    ██████╔╝    ███████╗    ██║  ██║             ╚████╔╝ 
//  ╚══════╝    ╚═╝  ╚═══╝    ╚═╝  ╚═╝     ╚═════╝     ╚═════╝     ╚══════╝    ╚═╝  ╚═╝              ╚═══╝  
//                                                                                                                                  
//                                                                                    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ПЕРЕМЕННЫЕ ЕНКОДЕРА

// распиновка
byte pinA = IN_ENKODER_CLK_PIN;          //Пин прерывания сигнальной линии енкодера
byte pinButton = IN_ENKODER_BUTTON_PIN;  //Пин прерывания нажатия кнопки
byte pinB = IN_ENKODER_DT_PIN;           //другой пин енкодера

long timeButtonPressed = 1000;    // Долгое удержание кнопки после 1 секунд. настройка поведения ниже ↓
#define LONG_PRESS_CONTINUES 0    // 1 будет выполнятся одно событие, 0 будут повторятся события пока нажата кнопка

volatile int state = 0;                 // Переменная хранящая статус вращения

// Переменные хранящие состояние действия до его выполнения
volatile bool flagCW            = false;     // Было ли вращение по часовой стрелке
volatile bool flagCCW           = false;     // Было ли вращение против часовой стрелки
volatile bool flagButton        = false;     // Было ли нажатие кнопки
volatile bool flagButtonLong    = false;     // Было ли долгое удержание кнопки

volatile long timeButtonDown    = 0;         // Переменная хранящая время нажатия кнопки
volatile bool isButtonDown      = false;     // Переменная хранящая время нажатия кнопки
volatile bool longPressReleased = false;     // Переменная для фиксации срабатывания долгого нажатия



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "chekparam.h"  // функции управления реле по установленным параметрам
#include "extmenu.h"    // extmenu
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ███████╗    ███╗   ██╗    ██╗  ██╗     ██████╗     ██████╗     ███████╗    ██████╗             ███████╗
//  ██╔════╝    ████╗  ██║    ██║ ██╔╝    ██╔═══██╗    ██╔══██╗    ██╔════╝    ██╔══██╗            ██╔════╝
//  █████╗      ██╔██╗ ██║    █████╔╝     ██║   ██║    ██║  ██║    █████╗      ██████╔╝            █████╗  
//  ██╔══╝      ██║╚██╗██║    ██╔═██╗     ██║   ██║    ██║  ██║    ██╔══╝      ██╔══██╗            ██╔══╝  
//  ███████╗    ██║ ╚████║    ██║  ██╗    ╚██████╔╝    ██████╔╝    ███████╗    ██║  ██║            ██║     
//  ╚══════╝    ╚═╝  ╚═══╝    ╚═╝  ╚═╝     ╚═════╝     ╚═════╝     ╚══════╝    ╚═╝  ╚═╝            ╚═╝     
//                                                                                                       
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ФУНКЦИИ ЕНКОДЕРА

void A(){

  bool pinAValue = digitalRead(pinA);        // Получаем состояние пинов A и B
  bool pinBValue = digitalRead(pinB);

  cli();                                    // Запрещаем обработку прерываний, чтобы не отвлекаться
  if (!pinAValue &&  pinBValue) state = 1;  // Если при спаде линии А на линии B единица, то вращение в одну сторону
  if (!pinAValue && !pinBValue) state = -1; // Если при спаде линии А на линии B ноль, то вращение в другую сторону
  if (pinAValue && state != 0) {
    if (state == 1 && !pinBValue || state == -1 && pinBValue) { // Если на линии А снова единица, фиксируем шаг
      if (state == 1)   flagCW = true;      // Флаг вращения по часовой стрелке
      if (state == -1) flagCCW = true;      // Флаг вращения против часовой стрелки
      state = 0;
    }
  }
  sei();                                    // Разрешаем обработку прерываний
}

void Button(){
  
  if (millis() - timeButtonDown < 50) return;
  bool pinButValue = digitalRead(pinButton);   // Получаем состояние пина кнопки

  cli();                                      // Запрещаем обработку прерываний, чтобы не отвлекаться
  timeButtonDown = millis();                  // Запоминаем время нажатия/отжатия

  if (!pinButValue) {                         // При нажатии подается инвертированный сигнал
    isButtonDown = true;                      // Устанавливаем флаг нажатия кнопки
  }
  else if (isButtonDown) {                    // Если кнопка отжата, смотрим не было ли выполнено действие
    if (!longPressReleased) {                 // Если долгое нажатие не было ни разу отработано, то...
      flagButton = true;                      // Если не было удержания, ставим флаг события обычного нажатия
    }
    isButtonDown = false;                     // Сбрасываем флаг нажатия
    longPressReleased = false;                // Сбрасываем флаг длительного удержания
  }
  sei();                                      // Разрешаем обработку прерываний
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ██╗  ██╗     █████╗      ██████╗    ██╗     ██╗
//  ██║  ██║    ██╔══██╗    ██╔════╝    ██║     ██║
//  ╚██████║    ███████║    ██║         ██████╗ ██║
//   ╚═══██║    ██╔══██║    ██║         ██╔══██╗██║
//       ██║    ██║  ██║    ╚██████╗    ██████╔╝██║
//       ╚═╝    ╚═╝  ╚═╝     ╚═════╝    ╚═════╝ ╚═╝
// 
//                                                    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///// часы DS3231 ..
byte decToBcd(byte val){
  	return ( (val/10*16) + (val%10) );
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte bcdToDec(byte val){
  	return ( (val/16*10) + (val%16) );
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void setDateDs1307(
	byte second,        // 0-59
	byte minute,        // 0-59
	byte hour,          // 0-23
	byte dayOfWeek,     // 1-7
	byte dayOfMonth,    // 1-28/29/30/31
	byte month,         // 1-12
	byte year           // 0-99
)
{
   	Wire.beginTransmission(0x68);
   	Wire.write(0);
   	Wire.write(decToBcd(second));    
   	Wire.write(decToBcd(minute));
   	Wire.write(decToBcd(hour));     
   	Wire.write(decToBcd(dayOfWeek));
   	Wire.write(decToBcd(dayOfMonth));
   	Wire.write(decToBcd(month));
   	Wire.write(decToBcd(year));
   	Wire.endTransmission();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void getDateDs1307(byte *second,
          		   byte *minute,
          		   byte *hour,
          		   byte *dayOfWeek,
          		   byte *dayOfMonth,
          		   byte *month,
          		   byte *year)
{

  	Wire.beginTransmission(0x68);
  	Wire.write(0);
  	Wire.endTransmission();

  	Wire.requestFrom(0x68, 7);

  	*second     = bcdToDec(Wire.read() & 0x7f);
  	*minute     = bcdToDec(Wire.read());
  	*hour       = bcdToDec(Wire.read() & 0x3f); 
  	*dayOfWeek  = bcdToDec(Wire.read());
  	*dayOfMonth = bcdToDec(Wire.read());
  	*month      = bcdToDec(Wire.read());
  	*year       = bcdToDec(Wire.read());
  	// if(*hour == 0){*hour = 24;}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
///// температура DS3231 ..
byte get3231Temp(){

  	byte tMSB, tLSB; 
  	byte temp3231;

  	Wire.beginTransmission(0x68);
  	Wire.write(0x11);
  	Wire.endTransmission();
  	Wire.requestFrom(0x68, 2);

  	if(Wire.available()) {

    	tMSB = Wire.read(); //2's complement int portion
    	tLSB = Wire.read(); //fraction portion

    	temp3231 = (tMSB & B01111111); //do 2's math on Tmsb
    	temp3231 += ( (tLSB >> 6) * 0.25 ); //only care about bits 7 & 8
  	}else{
    	//oh noes, no data!
  	}

  	return temp3231;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void getDhtData(byte *TE, byte *HU){
	
  	static Dht11 sensor(IN_DHT_DATA_PIN);

  	switch (sensor.read()) {

    	case Dht11::OK:
        *TE = sensor.getTemperature();
        *HU = sensor.getHumidity();
        break;

    	case Dht11::ERROR_CHECKSUM:    
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Checksum err"));
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;

    	case Dht11::ERROR_TIMEOUT:
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Time err"));
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;

    	default:
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Unknown err")); 
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void getDhtDataByte(void){
	
  	static Dht11 sensor(IN_DHT_DATA_PIN);

  	switch (sensor.read()) {

    	case Dht11::OK:
        TEMP = sensor.getTemperature();
        HMDT = sensor.getHumidity();      
        break;

    	case Dht11::ERROR_CHECKSUM:    
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Checksum err"));
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;

    	case Dht11::ERROR_TIMEOUT:
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Time err"));
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;

    	default:
        lcd.clear(); // очистить дисплей
        lcd.setCursor(0,0);
        lcd.println(F("DHT Unknown err")); 
        delay(1000);
        lcd.clear(); // очистить дисплей
        break;
    }
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                
//                                                                
//                                                                 ██████████╗ 
//  ███╗   ███╗    ███████╗    ███╗   ██╗    ██╗   ██╗            ███      ███╗
//  ████╗ ████║    ██╔════╝    ████╗  ██║    ██║   ██║            ██  ████  ██║
//  ██╔████╔██║    █████╗      ██╔██╗ ██║    ██║   ██║            ██  ████  ██║
//  ██║╚██╔╝██║    ██╔══╝      ██║╚██╗██║    ██║   ██║            ███      ███║
//  ██║ ╚═╝ ██║    ███████╗    ██║ ╚████║    ╚██████╔╝            ╚██████████╔╝
//  ╚═╝     ╚═╝    ╚══════╝    ╚═╝  ╚═══╝     ╚═════╝              ╚═════════╝ 
//                                                                
//                                                                
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t display_type = 1;
uint8_t max_display_type = 2;
void chekMenuLoop(unsigned int count = 1){

	horizontalStep = 0;
	vertikalStep = 0;
	// sei();                                      // Разрешаем обработку прерываний

	for(int i=0; i<count; i++){

		// chek enkoder
		//delay(200);                                 // задержка 200 мс
		enkoderChek();                              // проверка переменных енкодера
	 	if(vertikalStep > 0){

	 		// cli();
	 		i = count;
	 		menuLoop();
	 	}
	 	if(horizontalStep > 0){display_type ++;}
	 	else if(horizontalStep < 0){display_type --;}
	 	if(display_type > max_display_type){display_type = 1;}
	 	else if(display_type < 1){display_type = max_display_type;}
	 	if(horizontalStep != 0){lcd.clear();}
	}

	// cli();                                      // Запрещаем обработку прерываний, чтобы не отвлекаться
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void menuLoop(){

	lcd.clear();
  	lcd.setCursor(5, 0);
  	lcd.print(F("MENU"));

	delay(500);
	flagMenuState = 1;

	// sei();



	// cli();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ███████╗    ███╗   ██╗    ██╗  ██╗     ██████╗     ██████╗     ███████╗    ██████╗                 ██╗   
//  ██╔════╝    ████╗  ██║    ██║ ██╔╝    ██╔═══██╗    ██╔══██╗    ██╔════╝    ██╔══██╗                ██║   
//  █████╗      ██╔██╗ ██║    █████╔╝     ██║   ██║    ██║  ██║    █████╗      ██████╔╝                ██║   
//  ██╔══╝      ██║╚██╗██║    ██╔═██╗     ██║   ██║    ██║  ██║    ██╔══╝      ██╔══██╗                ╚═╝   
//  ███████╗    ██║ ╚████║    ██║  ██╗    ╚██████╔╝    ██████╔╝    ███████╗    ██║  ██║             ██▀██▀██╗
//  ╚══════╝    ╚═╝  ╚═══╝    ╚═╝  ╚═╝     ╚═════╝     ╚═════╝     ╚══════╝    ╚═╝  ╚═╝             ╚═╝╚═╝╚═╝
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         
// USER ENKODER F

void enkoderChek(){

  	if (millis() - timeButtonDown > timeButtonPressed && isButtonDown) { // Время длительного удержания наступило
  	  	flagButtonLong = true;
  	}

  	if (flagCW) {                             // Шаг вращения по часовой стрелке
  	  	// ....
  	  	horizontalStep ++;
  	  	Serial.println(F("turn_right"));
  	  	flagCW = false;                       // Действие обработано - сбрасываем флаг
  	}
  	if (flagCCW) {                            // Шаг вращения против часовой стрелки
  	  	// ...
  	  	horizontalStep --;
  	  	Serial.println(F("turn_left"));
  	  	flagCCW = false;                      // Действие обработано - сбрасываем флаг
  	}
  	if (flagButton) {                         // Кнопка нажата
  	  	// .
  	  	vertikalStep ++;
  	  	Serial.println(F("short_press"));
  	  	flagButton = false;                   // Действие обработано - сбрасываем флаг
  	}
  	if (flagButtonLong && isButtonDown) {   // Кнопка удерживается
  	  	if (!digitalRead(pinButton) && millis() - timeButtonDown > timeButtonPressed) { //Защита от ложного срабатывания
  	    // ..
  	  		vertikalStep --;
  	    	Serial.println(F("long_press"));
  	  	}

  	  	//================================= Настраиваем реакцию на долгое удержание кнопки =============================
  	  	// Для того, чтобы изменить это поведение, измените настройки в блоке ENKODER V
  	  	#if LONG_PRESS_CONTINUES == 0
  	  	// при долгом удержании кнопки, событие long_press повторяется каждые 1,5 секунды
  	  	timeButtonDown = millis(); // Сбрасываем таймер
  	  	longPressReleased = true;  // Флаг срабатывания держания, чтоб отсечь обычное нажатие при отпускании кнопки
  	  	#else
  	  	// при долгом удержании кнопки, событие long_press повторялось 1 раз
  	  	isButtonDown = false;                   // Программно "отжимаем" кнопку
  	  	#endif
  	  	//==============================================================================================================

  	  	flagButtonLong = false;               // Действие обработано - сбрасываем флаг
  	}
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  
//  
//  ██████╗     ██╗    ███████╗    ██████╗     ██╗          █████╗     ██╗   ██╗     ████████████████████████████████╗
//  ██╔══██╗    ██║    ██╔════╝    ██╔══██╗    ██║         ██╔══██╗    ╚██╗ ██╔╝     ██╔═══════════════════════════██║
//  ██║  ██║    ██║    ███████╗    ██████╔╝    ██║         ███████║     ╚████╔╝      ██║        GROW HACKER        ██║
//  ██║  ██║    ██║    ╚════██║    ██╔═══╝     ██║         ██╔══██║      ╚██╔╝       ██║                           ██║
//  ██████╔╝    ██║    ███████║    ██║         ███████╗    ██║  ██║       ██║        ████████████████████████████████║
//  ╚═════╝     ╚═╝    ╚══════╝    ╚═╝         ╚══════╝    ╚═╝  ╚═╝       ╚═╝        ╚═══════════════════════════════╝
//                                                                              
//  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void chekReleToPrint( byte rele){  // функция печатает на дисплее состояние выбранного выхода

	if(digitalRead(rele) == DW_H){
		lcd.write(byte(flagAnimaciiReleStateCounter));
	}else{
		lcd.write(byte(0));
	}
}

void calibrationTempHmdt(){
	TEMP += calibrValTEMP;
	HMDT += calibrValHMDT;
    // TEMP += masMenu[85][3];
    // HMDT += masMenu[86][3];
}

void animAtom(byte x,byte y,byte r){
	lcd.setCursor(x, y);
	lcd.print(F(" "));
	lcd.setCursor(x, y);
	chekReleToPrint(r);
}

unsigned int animationDelayVal = 500;

void animationReleDelay(unsigned int delMsek){
	unsigned int thsLOpDel = animationDelayVal;  // animation Delay
	int fcount = delMsek / thsLOpDel + 1;
	for(int i=0; i<fcount; i++){

		flagAnimaciiReleStateCounter ++;
		if(flagAnimaciiReleStateCounter > 4){flagAnimaciiReleStateCounter = 1;}

	  	animAtom(5, 0, OUT_SVETTIMER_RELE_PIN);
	  	animAtom(14, 0, OUT_TEMPERATURA_RELE_PIN);
	  	animAtom(5, 1, OUT_POLIVTIMER_RELE_PIN);
	  	animAtom(14, 1, OUT_VLAJNOST_RELE_PIN);

	  	delay(thsLOpDel);
	}
}
void animationReleDelayLinear(unsigned int delMsek){
	unsigned int thsLOpDel = animationDelayVal;  // animation Delay
	int fcount = delMsek / thsLOpDel + 1;
	for(int i=0; i<fcount; i++){

		flagAnimaciiReleStateCounter ++;
		if(flagAnimaciiReleStateCounter > 4){flagAnimaciiReleStateCounter = 1;}

		lcd.setCursor(0, 1);
  		lcd.print(F("l"));
	  	animAtom(1, 1, OUT_SVETTIMER_RELE_PIN);

	  	lcd.setCursor(4, 1);
  		lcd.print(F("w"));
	  	animAtom(5, 1, OUT_POLIVTIMER_RELE_PIN);

	  	lcd.setCursor(8, 1);
  		lcd.print(F("t"));
	  	animAtom(9, 1, OUT_TEMPERATURA_RELE_PIN);

	  	lcd.setCursor(12, 1);
  		lcd.print(F("h"));
	  	animAtom(13, 1, OUT_VLAJNOST_RELE_PIN);

	  	delay(thsLOpDel);
	}
}

void displayMaiin(unsigned int thsLOpDel = 1000){

	getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);  // запрос текущего времени
  	getDhtData(&TEMP, &HMDT);  // запрос текущей температуры и влажности
  	calibrationTempHmdt();     // калибровка температуры и влажности

  	// lcd.clear();
  	lcd.setCursor(0, 0);
  	lcd.print(F("LGHT"));
  	animAtom(5, 0, OUT_SVETTIMER_RELE_PIN);
  	lcd.setCursor(7, 0);
  	lcd.print(F("TEMP"));
  	lcd.setCursor(12, 0);
  	lcd.print(TEMP);
  	lcd.print(F(" "));
	animAtom(14, 0, OUT_TEMPERATURA_RELE_PIN);
  	lcd.setCursor(0, 1);
  	lcd.print(F("WTRG"));
	animAtom(5, 1, OUT_POLIVTIMER_RELE_PIN);
  	lcd.setCursor(7, 1);
  	lcd.print(F("HMDT"));
  	lcd.setCursor(12, 1);
  	lcd.print(HMDT);
  	lcd.print(F(" "));
	animAtom(14, 1, OUT_VLAJNOST_RELE_PIN);

  	animationReleDelay(thsLOpDel);
  	// delay(1000);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayMaiinLight(){}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayMaiinTemp(){}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayMaiinHumidity(){}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayMaiinTimer(){}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String zwf(byte chislo){
	String retstr = "";
	if(chislo < 10){retstr = "0";}
	retstr += String(chislo);
	return retstr;
}

void displayMaiinDateTime(unsigned int thsLOpDel = 1000){
	getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);  // запрос текущего времени
	// lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print(zwf(hour));lcd.print(F(":"));lcd.print(zwf(minute));/*lcd.print(F(":"));lcd.print(zwf(second));*/
	lcd.setCursor(7, 0);
	lcd.print(zwf(dayOfMonth));lcd.print(F("."));lcd.print(zwf(month));lcd.print(F("."));lcd.print(zwf(year));
	// delay(3000);
	animationReleDelayLinear(thsLOpDel);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void screenBrightnesF(byte _brght = 100){
	if(_brght >= 100){digitalWrite(OUT_YARKOST_DISPLEYA_PWM_PIN, HIGH);}
  	else if(_brght == 0){digitalWrite(OUT_YARKOST_DISPLEYA_PWM_PIN, LOW);}
  	else{analogWrite(OUT_YARKOST_DISPLEYA_PWM_PIN, map(_brght, 0, 100, 0, 255));}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void generalDisplayDisplay(){
	if(display_type == 1){displayMaiin(100);}      // основной дисплей
	else if(display_type == 2){displayMaiinDateTime(100);}  // вывод даты и времени на экран
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//   █████╗     ██████╗     ██████╗     ██╗   ██╗    ██╗    ███╗   ██╗     ██████╗             ███████╗
//  ██╔══██╗    ██╔══██╗    ██╔══██╗    ██║   ██║    ██║    ████╗  ██║    ██╔═══██╗            ██╔════╝
//  ███████║    ██████╔╝    ██║  ██║    ██║   ██║    ██║    ██╔██╗ ██║    ██║   ██║            █████╗  
//  ██╔══██║    ██╔══██╗    ██║  ██║    ██║   ██║    ██║    ██║╚██╗██║    ██║   ██║            ██╔══╝  
//  ██║  ██║    ██║  ██║    ██████╔╝    ╚██████╔╝    ██║    ██║ ╚████║    ╚██████╔╝            ██║     
//  ╚═╝  ╚═╝    ╚═╝  ╚═╝    ╚═════╝      ╚═════╝     ╚═╝    ╚═╝  ╚═══╝     ╚═════╝             ╚═╝     
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Arduino
void setup() {

	pinMode(OUT_SVETTIMER_RELE_PIN, OUTPUT);
	pinMode(OUT_TEMPERATURA_RELE_PIN, OUTPUT);
	pinMode(OUT_VLAJNOST_RELE_PIN, OUTPUT);
	pinMode(OUT_POLIVTIMER_RELE_PIN, OUTPUT);


	digitalWrite(OUT_SVETTIMER_RELE_PIN, DW_L);
	digitalWrite(OUT_TEMPERATURA_RELE_PIN, DW_L);
	digitalWrite(OUT_VLAJNOST_RELE_PIN, DW_L);
	digitalWrite(OUT_POLIVTIMER_RELE_PIN, DW_L);

	pinMode(pinA, INPUT);           // Пины в режим приема INPUT
  	pinMode(pinB, INPUT);           // Пины в режим приема INPUT
  	pinMode(pinButton, INPUT);      // Пины в режим приема INPUT
  	

	Serial.begin(250000);

	delay(100);

	Wire.begin();


	lcd.begin(); // иниализация дисплея LCD 16/2
  	lcd.clear(); // очистить дисплей

	pinMode(OUT_YARKOST_DISPLEYA_PWM_PIN, OUTPUT);

	// screenBrightnesF(yarkostDispleya);  // яркость экрана
	if(actualIndex == 63 && isParamEditMode){
        screenBrightnesF(tmpValue);
    }
    else{
        screenBrightnesF(masMenu[63][3]);
    }

  	lcd.print(F("  GROW HACKER"));
  	lcd.setCursor(0, 1);
  	lcd.print(F("    V_1.0.1"));
  	delay(2000);

    symblPack1();

 	// УСТАНОВКА ЧАСОВ:↓
 	/*
  	second = 30;
  	minute = 50;
  	hour = 23;
  	dayOfWeek = 5; // день недели
  	dayOfMonth = 8; // день
  	month = 2;
  	year = 19;

  	setDateDs1307(second, minute, hour, dayOfWeek, dayOfMonth, month, year);
 	*/

  	attachInterrupt(0, A, CHANGE);        // Настраиваем обработчик прерываний по изменению сигнала на линии A
  	attachInterrupt(1, Button, CHANGE);   // Настраиваем обработчик прерываний по изменению сигнала нажатия кнопки

  	lcd.clear();

  	displayMaiin(1000);

  	// extMenuSetup();  // --------------------------->>>

  	// test
	// digitalWrite(OUT_SVETTIMER_RELE_PIN, DW_H);
	// digitalWrite(OUT_TEMPERATURA_RELE_PIN, DW_H);
	// digitalWrite(OUT_VLAJNOST_RELE_PIN, DW_H);
	// digitalWrite(OUT_POLIVTIMER_RELE_PIN, DW_H);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void loop() {


	chekMenuLoop(1);      // чек енкодера на случай входа в меню и переключение экранов (раз)

	extMenuLoop();       // внешнее меню
 
	chekParam();            // управление реле

	generalDisplayDisplay();

	chekParam();            // управление реле


	if(actualIndex == 63 && isParamEditMode){
		screenBrightnesF(tmpValue);
	}
	else{
		screenBrightnesF(masMenu[63][3]);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
